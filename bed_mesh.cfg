
#  Bed Mesh Definition

[bed_mesh]
##  Начальная конечная конечная точка сетки
mesh_min: 3,5
mesh_max: 341,277
speed: 20
horizontal_move_z: 2.0
probe_count: 23,17
#17,13
## Используемый алгоритм интерполяции. Может быть как "lagrange", так
## и "bicubic". Эта опция не повлияет на сетки 3x3, которые вынуждены
## использовать выборку Лагранжа. Значение по умолчанию lagrange.
algorithm: bicubic
##[(7x7)-1] / 2 = 24
##[(5x5)-1] / 2 = 12
relative_reference_index: 390
## Позиция gcode z, в которой можно начать постепенное отключение
## z-регулировки, когда включено затухание.  Значение по умолчанию 1.0.
#fade_start: 1
## Позиция gcode z, в которой завершается поэтапное прекращение.
## Если установлено значение ниже fade_start, функция fade отключена.
## Следует отметить, что затухание может привести к нежелательному
## масштабированию вдоль оси z отпечатка.  Если пользователь хочет включить
## fade, рекомендуется значение 10.0. Значение по умолчанию равно 0.0,
## что отключает затухание.
#fade_end: 10
## Позиция z, в которой должно сходиться затухание. Если этому значению
## присвоено ненулевое значение, оно должно находиться в диапазоне z-значений
## в сетке. Пользователи, которые хотят перейти в положение самонаведения z,
## должны установить это значение равным 0.
## По умолчанию используется среднее значение z сетки.
#fade_target: 0
## Расстояние (в мм) вдоль движения, чтобы проверить наличие split_delta_z.
## Это также минимальная длина, на которую можно разделить ход.
## Значение по умолчанию 5.0.
move_check_distance: 3
## Величина разницы Z (в мм) вдоль хода, которая вызовет разделение.
## Значение по умолчанию равно .025.
split_delta_z: 0.01
## Пара целых чисел,разделенных запятыми (X, Y), определяющая количество
## точек на сегмент для интерполяции в сетке вдоль каждой оси. "Сегмент"
## можно определить как пространство между каждой исследуемой точкой.
## Пользователь может ввести одно значение, которое будет применено
## к обеим осям.  Значение по умолчанию равно 2,2.
mesh_pps: 0,0
## При использовании bicubic алгоритма параметр натяжения выше может
## быть применен для изменения величины интерполированного наклона.
## Большие числа увеличат величину наклона, что приведет к большей
## кривизне сетки. Значение по умолчанию равно .2.
#bicubic_tension: 0.2


#  Macros

#
# Предупреждение: Если вы используете имена гибких пластин в вашей
# сохраненной сетке, чем:
#   - убедитесь, что он не содержит пробелов
#   - убедитесь, что он не содержит специальных характеристик
#   - убедитесь, что он не содержит немецкого "umlaut" (äöü и β)
#
# Все макросы написаны таким образом, что они будут работать без блока
# [save_variables], а также без flexplate.cfg
#

[gcode_macro BED_MESH_CALIBRATE]
rename_existing: BED_MESH_CALIBRATE_BASE
gcode:
  {% set user = printer['gcode_macro _USER_VARIABLE'] %}
  {% if "xyz" not in printer.toolhead.homed_axes %} G28 {% endif %}
  BED_MESH_CLEAR
  _SET_ACC VAL=HOME
  BED_MESH_CALIBRATE_BASE {rawparams}
  _SET_ACC
    
## use BED_MESH_STORE                       -> generate MESH and park in the middle
## use BED_MESH_STORE SAVE=now              -> generate MESH and park in the middle and save immediately 
## use BED_MESH_STORE PARK=false            -> generate MESH
## use BED_MESH_STORE SAVE=later            -> generate MESH and park in the middle and save it later 
[gcode_macro BED_MESH_STORE]
description: Generate a mesh, name it and run save_config if requested
variable_save_at_end: False
gcode:
  {% set user = printer['gcode_macro _USER_VARIABLE'] %}
  {% set name = '' if printer.save_variables.variables.plates is not defined 
           else printer.save_variables.variables.plates.array[printer.save_variables.variables.plates.index].name + '-' %}
  {% set mesh_name = name + "Bed_Temp-" + printer.heater_bed.target|int|string + "C" %}
  {action_respond_info("BED_MESH: Generate \"%s\"" % mesh_name)}
  BED_MESH_CALIBRATE PROFILE={mesh_name}
  {% if params.PARK|default('true')|lower == 'true' %}
    G90                                                                  ; set absolute
    G0 Z{user.park.bed.z} F{user.speed.z_hop}                            ; lift first
    G0 X{use.park.bed.x} Y{user.park.bed.y} F{user.speed.travel}         ; park toolhead
    {% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %} ; set it back to relative
  {% endif %}
  {% if params.SAVE|default('none')|lower == 'now' %}
    _PRINT_AR T="BED_MESH: Save Config!"
    SAVE_CONFIG
  {% elif params.SAVE|default('none')|lower == 'later' %}
    _PRINT_AR T="BED_MESH: Save Config after print done"
    SET_GCODE_VARIABLE MACRO=BED_MESH_STORE VARIABLE=save_at_end VALUE=True
  {% endif %}

## use BED_MESH_LOAD           -> загрузите существующую СЕТКУ
## use BED_MESH_LOAD AUTO=true -> загрузите существующую СЕТКУ или создайте новую и подготовьте ее к сохранению после завершения печати
[gcode_macro BED_MESH_LOAD]
description: Load an existing mesh or generate a new one
gcode:
  {% set name = '' if printer.save_variables.variables.plates is not defined 
           else printer.save_variables.variables.plates.array[printer.save_variables.variables.plates.index].name + '-' %}
  {% set mesh_name = name + "Bed_Temp-" + printer.heater_bed.target|int|string + "C" %}
  {% if printer.configfile.config["bed_mesh " + mesh_name] is defined %}
    {action_respond_info("BED_MESH: \"%s\" loaded" % mesh_name)}
    BED_MESH_CLEAR
    BED_MESH_PROFILE LOAD={mesh_name}
  {% elif params.AUTO|default('false')|lower == 'true' %}
    {action_respond_info("BED_MESH: \"%s\" needs to be generated" % mesh_name)}
    BED_MESH_STORE SAVE=none PARK=false
  {% else %}
    {action_respond_info("BED_MESH: ERROR \"%s\" not defined" % mesh_name)}
  {% endif %}

## добавьте это в свой PRINT_END, чтобы сохранить сетку, если это необходимо,
## через 10 секунд после завершения печати
## UPDATE_DELAYED_GCODE ID=_BED_MESH_SAVE DURATION=10
[delayed_gcode _BED_MESH_SAVE]
gcode:
  {% if printer["gcode_macro MESH_STORE"].save_at_end %}
    {action_respond_info("BED_MESH: Save Config!")}
    SAVE_CONFIG
  {% endif %}
